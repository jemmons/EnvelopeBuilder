namespace EnvelopeBuilder 
{
    namespace Segments 
    {
        processor EnvelopeSegment 
        {
            input stream float in;
            input value float seconds;
            input value float targetLevel;
            input value float curve;
            input event void latch;
            input event void free;
            output event void trigger;
            output stream float out;

            SegmentState state = SegmentState::Free;
            float currentLevel;
            float initialLevel;
            node phasor = Components::OneShotPhasor;

            event latch () 
            {
                initialLevel = currentLevel;
                phasor.trigger <- void;
                // We cheat a little here. The phasor needs a frame to reset itself to zero.
                phasor.advance();
                state = SegmentState::Latched;
            }

            event free () 
            {
                state = SegmentState::Free;
            }
        
            void main () 
            {
                loop 
                {
                    if (state == SegmentState::Free) 
                    {
                        currentLevel = in;
                    } 
                    else if (state == SegmentState::Latched)
                    {
                        if (phasor.phase == 1.f) 
                        {
                            trigger <- void;
                            currentLevel = targetLevel;
                            state = SegmentState::Trigged;
                        }                        
                        else {
                            let phaseFactor = (phasor.phase / (curve * phasor.phase + (1.f - curve)));
                            currentLevel = (targetLevel - initialLevel) * phaseFactor + initialLevel;
                        }
                    }
                    else if (state == SegmentState::Trigged)
                    {
                        currentLevel = targetLevel;
                    }
                    out <- currentLevel;
                    phasor.seconds <- seconds;
                    phasor.advance();
                    advance();
                }
            }
        }
    }
}